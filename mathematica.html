define a combinatorial function

In[1]:= F[x_] = Sum[i, {i, 1, x}]

Out[1]= 1/2 x (1 + x)

In[2]:= F[3]

Out[2]= 6

In[5]:= Pa = PartitionsP

Out[5]= PartitionsP

In[6]:= Pa[3]

Out[6]= 3

In[7]:= Table[Pa[x], {x, 1, 10}]

Out[7]= {1, 2, 3, 5, 7, 11, 15, 22, 30, 42}


-----------------------
Clear[x]

用Clear函数
格式如下：
Clear["`*"]
可能看不清楚，后面是英文双引号，引号中间还有两个符号，一个是按ESC键下面那个键，再一个是星号*
这个函数能清除掉所有的变量赋值

-------------------


使用Range和一点点函数式编程的方法：

In[]:= (Range[3]*#)&/@Range[3]
Out[]= {{1,2,3},{2,4,6},{3,6,9}}
In[]:= Range[#+1,2*#]&/@Range[4]
Out[]= {{2},{3,4},{4,5,6},{5,6,7,8}}
In[]:= Nest[Partition[#,3,1]&,Range[3,8],2]
Out[]= {{{3,4,5},{4,5,6},{5,6,7}},{{4,5,6},{5,6,7},{6,7,8}}}
In[]:= Map[Sin,Range[10]]
Out[]= {Sin[1],Sin[2],Sin[3],Sin[4],Sin[5],Sin[6],Sin[7],Sin[8],Sin[9],Sin[10]}
In[]:= Clear[x];
       x^Range[10]
Out[]= {x,x^2,x^3,x^4,x^5,x^6,x^7,x^8,x^9,x^10}
上面的例子对于现在的我们来说并不容易理解。在这里我们涉及这部分是想表明Range是很有用的，并且澄清Table的角色。实际上，Table可以认为是一种优化的循环。通常用Table产生列表比Do，For或者While 要更快一些。但是在函数式编程中，Table并不常用，不像Range，现在我们可以看到为什么我们能够得到同样的结果，并且，后者运行起来会更快。

ref:https://zh.wikibooks.org/wiki/Mathematica/列表
----------------
